***  Variables  ***

x=2 #int  assigning 2 to x,assigning value
y=5 #int 
# Python is a dynamically typed language,you don't need to specify the type of variable,whatever content you are assigning to a variable the that content decides the type.
xy=7.2 #float
# We need to assign the names of the variables descriptive way for readability.
c=2+4j #complex
s="hellow" #string 
# Double quotes or single quotes no difference between them.
# String is a sequance of characthers
s="12" #string
a,b=4,5.0 #mutliple assignment #a is a int #b is a float because of the decimal points
# Each variable keeps a space in memory. To free this space, we delete the variables we no longer use from the memory with this command.
del x 
print("x") #error
# We can see how many variable that we have rn in the memory with this command
%whos
x=5 #int
x=5.7 #float it changed now
print(type(x)) #<class 'int'>

***  Operators  ***


+ addition           // floor or integer division (10//3=3 just quotient)
- subtraction        ** to the power of
/ division
% mod (27%5=2)
* multiplication

# tab completion
# esc m to markdown
# shift enter to new cell
# float > integer so 6+3.2= float
# if you don't assign your variable anywhere like you code directly like 10/3 it is assigning to _(underscore) by default
# underscore is contains most recent variable or operator that we've created
# we shouldn't assign anything to _ because we can't use python built in proparties properly
# we can start with a underscore when we named the variables but nothing else
# camelNotation

***  Type Bool and Comparisons  ***

# bool = True,False
# and(binary operator it takes two),or,not(unary operator it just takes one variable)
not(True) = False
# only one equal sign means assignment =,two equal sign means we are checking wheter the two values are equal or not ==
# != not equal the result is true if the two variables are different from each other

!!! 3==3.0  TRUE !!!
# because they are comparing the values by discarding the decimal points.
# int gets implicitly converted to float in this case.

***  Some Useful Functions  ***

# Functions are sometimes,particularly a built in function is basically a feature form the language that is supplied for users to achieve particular task.

* Round Function *

# Round functios finds the nearest integer
# round(4.6)=5  round is a Function 4.6 is a "argument"
# round(4.3)=4  round is a Function 4.3 is a "argument"
# round(4.55842,3) 4.558 the result will be there decimal places

* Divmod Function *

  divmod(x,y)  = (quotient,reminder)
# divmod(27,5) = (5,2) if we have 2 or more elements we call these "tuples" ordered list
# divmod = (//,%) is the same thing

* isinstance Function *

# Returns True if the first argument is an instance of that class. Multiple classes can also be checked at once. 
# print(isinstance(1,int))   True
# print(isinstance(1.0,int)) False
# print(isinstance(1.0,(int,float))) if it is one of these returns True

* Power Function *

# pow(x,y,z) = x raise to the power y and remainder by z (x**y)%z
# pow(2,4,7) = 2 -> 2**4=16%7=2

* Input Function *

# a= input("Enter something") whatever the user enter here it is string even if 34 it is also string we will convert afterwards.
x=input("enter a number : ")
type(x) -> str
x = int(x) 
type(x) -> int we converted str to int

a = float(input("Enter a real number : "))

# pow?,pow??,help(pow),help(input) we can check like this how can we use one function

***  Control Flow  ***
if b>a:
  print("b is greater than a")
else:
  print("a is greater than b")

------------

a = int(input())
b = int(input())
if a>b:
    print("a is greater than b,a and b:",a,b)
elif a==b:
    print("a and b are equal,a and b:",a,b)
else:
    print("b is greater than a,a and b:",a,b)

------Short Form of If Else-------

a=9
b=10
print("A") if a>b else print("=") if a==b else print("B")

--------Calculating Grade----------

a = int(input("Enter Marks: "))
if a>=85:
    print("A grade")
elif (a>=80) and (a<85):
    print("A- grade")
elif (a>=75) and (a<80):
    print("B grade")
elif (a>=70) and (a<75):
    print("B- grade")
else:
    print("Below Avarage")

-------Fun Part-------------

a = 3
if a>10:
    print(">10")
elif not(a>10):
    print("else part")

* Nested If *

x = int(input("Enter a number : "))
if x>10:
    print("your number is greater than ten, ")
    if x>20:
        print("and also above 20!")
    else:
        print("but not above 20.")

!! indentation defines if else blocks

#single line comment
"""
multi line comment
"""

User will enter a floating number let say 238.915. Your task is to find 
out the integer portion before the point (in this case 238)
and then check if that integer portion is an even number or not.

x = float(input("Enter a floating number : "))
y = round(x)
if x>0:
    if y>x:
        intPortion = y-1
    else:
        intPortion = y
else:
    if y>x: 
        intPortion = y
    else:
        intPortion = y+1

!! if :
   else :
     pass (=do nothing)

if intPortion%2 == 0:
    print("even")
else:
    print("odd")

***  Loops  ***

* While Loop ; condition loop *

n = int(input("How many times should I repeat? :"))
i=1
while i<n:
    print(i)
    i+=1
print("done")

* Break Continue *

# A break statement wherever written inside the body of the loop tells that exit the loop immediately 
# whenver this break encountered,it exits the loop and brings you outside of the loop.

# Continue basically skips the remaining body of the loop and starts another iteration.

* For Loop ; counter loop *

L = []
for i in range(10):
    print(i+1)
    L.append(i**2)

# 10 is not included,9 is the last iteration

L = []
for i in range(0:10:2):  # range(0,10,2) start from 0(included) end at 9(not included) +2 +2 +2 0,2,4,6,8 -> 0,4,16,36,64
    print(i+1)
    L.append(i**2)
print(L)

# set {} list []

S = {"apple",4.9,"cherry"}
i = 1
for x in S:
    print(x)
    i += 1
    if i==3:
        break
    else:
        pass
else:
    print("Loop terminates with success")
print("Out side the loop")

-----------------------------

D = {"A":10,"B":-19,"C":"abc"}  # dictinorary
for x in D:
    print(x,D[x])

"""
Given a list of numbers [1,2,4,-5,7,9,3,2] make another list that contains all the items 
in sorted order from min to max. Your result will be another list like [-5,1,2,2,3,7,9].
"""
L = [1,2,4,-5,7,9,3,2]
for j in range(len(L)):
    m = L[j]
    idx = j
    c = j
    for i in range(j,len(L)):
        if L[i]<m:
            m = L[i]
            idx = c
        c+=1
    tmp = L[j]
    L[j] = m
    L[idx] = tmp
print(L)

***  Function  ***

# Function contain all the tasks that you need the perform,
# whenever you need to perform just call function and whole task that is under this function will be working.
def printSuccess():
    print("The task was successful")
    print("Moving to the next task")
    print("Send me the next task")

printSuccess()

# doc string : documentation for your function
def printSuccess2():
    """
    This function is doing nothing except printing a message. This message is "hellow"
    """
    print("Hellow")

printSuccess2?  -> we can check doc string like this
printSuccess2?? -> whole implementation coming in front of us

# write a doc string everytime you write a code.
# there is a lot of function is coming from C because of their efficiency
help(printSuccess2)

* Functions(input arguments) *

def printMessage(msg):
    print(msg)
# call
printMessage("rabia")

----------------------
def printMsg(msg):
    """
    The function prints the message supplied by the user or prints that msg is not in the form of string.
    """
    if isinstance(msg,str):
        print(msg)
    else:
        print("Your input argument is not a string")
        print("Here is the type what you have supplied : ",type(msg))

# we can call like these too
y = "hellow"
printMsg(y)

* Multiple Arguments *

def mypow(a,b):
    """This function computes power just like builtin pow function
    """
    c = a**b
    print(c)

-------------------

def checkArgs(a,b,c):
    if isinstance(a,(int,float)) and isinstance(b,(int,float)) and isinstance(c,(int,float)):
        print((a+b+c)**2)
    else:
        print("Error: the input arguments are not of the expected types")

# You have to define the number of whatever the it is expecting,you have to supply exactly as many.Otherwise,you are getting an error.

* Order of Input *

def f(c2,c1,c3):
  print(c1,c2,c3)

# if you gave f(2,3,4) then c2=2 c1=3 c3=4 order is important.
# f(c1="A",c2="B",c3="C") then order is not important.

* Variables Inside *
def add(x,y):
    c=x+y    # we can't receive this c value outside the function it will be lost when the inside the function is complete.

def add(x,y):
    return x+y # this way we can reach x+y outside the function
----------
# Variables that are available before the call,they are available inside the function,but the variables inside the functions are not available outside.
def f():
  prints(a)

# calling this function
a=7
f(): -> 7
----------
def f():
  a=7 (local variable) # local variable will be gone after the execution
  prints(a) 

# if there is no a,but you still call F then either you will get an error or this might be a global variable or defined in some package.
# scope of variable : if we define a variable inside a function it is not accessible outside the function.
# Otherwise if it is defined outside we can use both inside and outside.

# empty functions returns none this means function always return something.

------------------------------------

def h():
    print("A")
    a=3
    b=5
    c=a+b
    print("something")
    return                  # it is exit like a break statement exiting right away
    print("B")
    print("C")

----------------------------------

def r():
    a=5
    b=7
    d="something"
    return a,b,d            # we can return more than 1 value even if they are different type

* Variable Number of Input Arguments * 
def add(*args):              # we can pass as many as we what arguments
    sum = 0
    for i in range(len(args)):
        sum += args[i]
    return sum
-------------------------------
f(c1="a") c1->key a->value key-value pairs
-----------------------
def f(**c):
    for x in c:
        print(x,c[x])

# call
f(a=1,b=2,c=3)
* Default Values *

* Default Values *
def f(sum=0):   # 0 is assigned to sum when we run this cell,not when we call the function.
    print(sum)

# call
f() # return 0 because it is a default value
f(5) # return 5

# We have 2 different place in memory for basic variables,but for some variable for example
# L={1,2,3} and L2 = l then L have 2 different name L and L2 in the memory.

------------------------------------

L = [1,2,3]
L2 = L
L2[0] = -9
print(L)         # -0,2,3

-----------------------------------
def ff(L=[1,2]):              # This default L is assigning to when the function is running not when you
    for i in L:
        print(i)
# call 1
L2 = [12,3,4]
ff(L2)                        # 12,3,4

# call 2
ff()                          # 1,2
